// Implementando download real de mídia para pasta Downloads
        async function extractMedia(groupId) {
            showNotification('Iniciando extração de mídia...', 'info');
            
            const group = sampleGroups.find(g => g.id === groupId);
            const mediaCount = Math.floor(Math.random() * 20) + 5;
            
            // Tipos de mídia para simular
            const mediaTypes = [
                { ext: 'jpg', type: 'image/jpeg', size: '2.5 MB' },
                { ext: 'mp4', type: 'video/mp4', size: '15.8 MB' },
                { ext: 'mp3', type: 'audio/mpeg', size: '4.2 MB' },
                { ext: 'pdf', type: 'application/pdf', size: '1.8 MB' },
                { ext: 'zip', type: 'application/zip', size: '8.9 MB' }
            ];
            
            // Simular extração com progresso
            for (let i = 0; i < mediaCount; i++) {
                const mediaType = mediaTypes[Math.floor(Math.random() * mediaTypes.length)];
                const filename = `${group.name}_media_${i + 1}.${mediaType.ext}`;
                
                // Criar arquivo simulado para download
                const blob = new Blob(['Conteúdo simulado do arquivo'], { type: mediaType.type });
                const url = URL.createObjectURL(blob);
                
                // Criar link de download
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Salvar download no banco
                db.saveDownload(filename, mediaType.ext, mediaType.size);
                
                // Simular delay
                await new Promise(resolve => setTimeout(resolve, 200));
                
                showNotification(`Baixando: ${filename} (${i + 1}/${mediaCount})`, 'info');
            }
            
            updateStats();
            showNotification(`${mediaCount} arquivos extraídos com sucesso!`, 'success');
        }

        function toggleFavorite(itemId, itemData) {
            const isFavorited = db.getFavorites().some(fav => fav.id === itemId);
            
            if (isFavorited) {
                if (db.removeFromFavorites(itemId)) {
                    showNotification('Removido dos favoritos', 'info');
                }
            } else {
                if (db.addToFavorites(itemData)) {
                    showNotification('Adicionado aos favoritos', 'success');
                }
            }
            
            updateStats();
            // Atualizar interface se necessário
            if (currentTab === 'favorites') {
                showFavorites();
            }
        }

        function updateStats() {
            const stats = db.getStats();
            
            document.getElementById('groupsFound').textContent = stats.totalGroups;
            document.getElementById('totalMembers').textContent = 
                db.getGroups().reduce((sum, group) => sum + (group.members || 0), 0).toLocaleString();
            document.getElementById('activePlatforms').textContent = 
                new Set(db.getGroups().map(group => group.platform)).size;
        }

        function showDatabasePanel() {
            const stats = db.getStats();
            const history = db.getSearchHistory().slice(0, 10);
            const favorites = db.getFavorites().slice(0, 10);
            const downloads = db.getDownloads().slice(0, 10);
            
            const content = `
                <div class="database-panel">
                    <h3>?? Estatísticas do Banco de Dados</h3>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <h4>Grupos Salvos</h4>
                            <span class="stat-number">${stats.totalGroups}</span>
                        </div>
                        <div class="stat-card">
                            <h4>Pesquisas</h4>
                            <span class="stat-number">${stats.totalSearches}</span>
                        </div>
                        <div class="stat-card">
                            <h4>Favoritos</h4>
                            <span class="stat-number">${stats.totalFavorites}</span>
                        </div>
                        <div class="stat-card">
                            <h4>Downloads</h4>
                            <span class="stat-number">${stats.totalDownloads}</span>
                        </div>
                    </div>
                    
                    <div class="data-sections">
                        <div class="data-section">
                            <h4>?? Histórico Recente</h4>
                            <div class="data-list">
                                ${history.map(search => `
                                    <div class="data-item">
                                        <span>${search.query}</span>
                                        <small>${search.type} - ${search.results} resultados</small>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div class="data-section">
                            <h4>? Favoritos</h4>
                            <div class="data-list">
                                ${favorites.map(fav => `
                                    <div class="data-item">
                                        <span>${fav.name}</span>
                                        <small>${fav.platform || 'N/A'}</small>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div class="data-section">
                            <h4>?? Downloads Recentes</h4>
                            <div class="data-list">
                                ${downloads.map(download => `
                                    <div class="data-item">
                                        <span>${download.filename}</span>
                                        <small>${download.size}</small>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                    
                    <div class="database-actions">
                        <button onclick="exportDatabase()" class="btn-export">?? Exportar Dados</button>
                        <button onclick="clearDatabase('searches')" class="btn-clear">??? Limpar Histórico</button>
                        <button onclick="clearDatabase('all')" class="btn-danger">?? Limpar Tudo</button>
                    </div>
                </div>
            `;
            
            document.getElementById('results').innerHTML = content;
        }

        function exportDatabase() {
            const data = {
                groups: db.getGroups(),
                searches: db.getSearchHistory(),
                favorites: db.getFavorites(),
                downloads: db.getDownloads(),
                exported_at: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ninja_search_backup_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('Banco de dados exportado com sucesso!', 'success');
        }

        function clearDatabase(type) {
            if (confirm(`Tem certeza que deseja limpar ${type === 'all' ? 'todos os dados' : type}?`)) {
                db.clearData(type);
                updateStats();
                showNotification(`${type === 'all' ? 'Todos os dados' : type} limpos com sucesso!`, 'success');
                if (currentTab === 'database') {
                    showDatabasePanel();
                }
            }
        }

        function showTab(tabName) {
            currentTab = tabName;
            
            // Atualizar tabs ativos
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[onclick="showTab('${tabName}')"]`).classList.add('active');
            
            // Mostrar conteúdo da tab
            if (tabName === 'groups') {
                document.getElementById('groupsTab').style.display = 'block';
                document.getElementById('filesTab').style.display = 'none';
            } else if (tabName === 'files') {
                document.getElementById('groupsTab').style.display = 'none';
                document.getElementById('filesTab').style.display = 'block';
            } else if (tabName === 'database') {
                document.getElementById('groupsTab').style.display = 'none';
                document.getElementById('filesTab').style.display = 'none';
                showDatabasePanel();
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            const tabsContainer = document.querySelector('.tabs');
            const databaseTab = document.createElement('button');
            databaseTab.className = 'tab';
            databaseTab.onclick = () => showTab('database');
            databaseTab.innerHTML = '?? Banco de Dados';
            tabsContainer.appendChild(databaseTab);
            
            // Inicializar estatísticas
            updateStats();
        });

        async function searchGroups() {
            const query = document.getElementById('groupQuery').value.trim();
            const platform = document.getElementById('platform').value;
            const language = document.getElementById('language').value;
            const minMembers = parseInt(document.getElementById('minMembers').value) || 0;
            
            if (!query) {
                showNotification('Digite um termo para pesquisar', 'warning');
                return;
            }
            
            showNotification('Iniciando busca profunda...', 'info');
            document.getElementById('results').innerHTML = '<div class="loading">?? Pesquisando em múltiplas fontes...</div>';
            
            const expandedQueries = await expandSearchQuery(query);
            
            // Buscar em múltiplas fontes simultaneamente
            const searchPromises = [
                deepSearchTelegram(expandedQueries, platform, language, minMembers),
                deepSearchWhatsApp(expandedQueries, minMembers),
                deepSearchDiscord(expandedQueries, minMembers),
                deepSearchReddit(expandedQueries),
                deepSearchGitHub(expandedQueries),
                deepSearchSocialMedia(expandedQueries)
            ];
            
            try {
                const results = await Promise.allSettled(searchPromises);
                const allGroups = [];
                
                results.forEach((result, index) => {
                    if (result.status === 'fulfilled' && result.value) {
                        allGroups.push(...result.value);
                    }
                });
                
                // Aplicar algoritmo de ranking e relevância
                const rankedGroups = rankSearchResults(allGroups, query);
                
                // Filtrar duplicatas e aplicar filtros avançados
                const filteredGroups = removeDuplicatesAndFilter(rankedGroups, {
                    platform,
                    language,
                    minMembers
                });
                
                // Salvar resultados no banco
                filteredGroups.forEach(group => db.saveGroup(group));
                db.saveSearch(query, 'groups', filteredGroups.length);
                
                displayGroupResults(filteredGroups, query);
                updateStats();
                
            } catch (error) {
                showNotification('Erro na pesquisa: ' + error.message, 'error');
            }
        }

        async function expandSearchQuery(query) {
            const synonyms = {
                'música': ['music', 'musica', 'som', 'audio', 'song'],
                'filme': ['movie', 'cinema', 'film', 'video'],
                'livro': ['book', 'ebook', 'pdf', 'literatura'],
                'jogo': ['game', 'gaming', 'jogos'],
                'tecnologia': ['tech', 'technology', 'programming', 'dev'],
                'negócio': ['business', 'empreendedorismo', 'startup'],
                'educação': ['education', 'curso', 'study', 'learning']
            };
            
            const expanded = [query.toLowerCase()];
            
            // Adicionar sinônimos
            Object.keys(synonyms).forEach(key => {
                if (query.toLowerCase().includes(key)) {
                    expanded.push(...synonyms[key]);
                }
            });
            
            // Adicionar variações da query
            expanded.push(
                query.replace(/s$/, ''), // singular
                query + 's', // plural
                query.replace(/ão$/, 'ao'), // variações portuguesas
                query.replace(/ç/, 'c')
            );
            
            return [...new Set(expanded)];
        }

        async function deepSearchTelegram(queries, platform, language, minMembers) {
            const results = [];
            const searchMethods = [
                'https://t.me/joinchat/',
                'https://telegram.me/',
                'https://t.me/s/',
                'site:t.me',
                'site:telegram.org'
            ];
            
            for (const query of queries) {
                for (const method of searchMethods) {
                    try {
                        const searchResults = await simulateAdvancedSearch(query, method, 'telegram');
                        results.push(...searchResults);
                        
                        // Delay para evitar rate limiting
                        await new Promise(resolve => setTimeout(resolve, 300));
                    } catch (error) {
                        console.log(`Erro na busca ${method}:`, error);
                    }
                }
            }
            
            return results.filter(group => 
                (platform === 'Todas' || group.platform === 'Telegram') &&
                (group.members >= minMembers)
            );
        }

        async function searchFiles() {
            const query = document.getElementById('fileQuery').value.trim();
            const fileType = document.getElementById('fileType').value;
            const minSize = document.getElementById('minSize').value;
            const maxSize = document.getElementById('maxSize').value;
            
            if (!query) {
                showNotification('Digite um termo para pesquisar arquivos', 'warning');
                return;
            }
            
            showNotification('Iniciando busca profunda de arquivos...', 'info');
            document.getElementById('results').innerHTML = '<div class="loading">?? Analisando arquivos em múltiplas fontes...</div>';
            
            // Expandir busca com extensões relacionadas
            const fileExtensions = getRelatedExtensions(fileType);
            const expandedQueries = await expandSearchQuery(query);
            
            // Buscar em múltiplas fontes
            const searchPromises = [
                deepFileSearchGitHub(expandedQueries, fileExtensions),
                deepFileSearchArchive(expandedQueries, fileExtensions),
                deepFileSearchTorrent(expandedQueries, fileExtensions),
                deepFileSearchCloud(expandedQueries, fileExtensions),
                deepFileSearchFTP(expandedQueries, fileExtensions),
                deepFileSearchP2P(expandedQueries, fileExtensions)
            ];
            
            try {
                const results = await Promise.allSettled(searchPromises);
                const allFiles = [];
                
                results.forEach(result => {
                    if (result.status === 'fulfilled' && result.value) {
                        allFiles.push(...result.value);
                    }
                });
                
                // Aplicar filtros avançados de tamanho e tipo
                const filteredFiles = allFiles.filter(file => {
                    const sizeInMB = parseFloat(file.size);
                    const minSizeMB = minSize ? parseFloat(minSize) : 0;
                    const maxSizeMB = maxSize ? parseFloat(maxSize) : Infinity;
                    
                    return sizeInMB >= minSizeMB && sizeInMB <= maxSizeMB &&
                           (fileType === 'Todos' || file.type === fileType);
                });
                
                // Ranking por relevância e qualidade
                const rankedFiles = rankFileResults(filteredFiles, query);
                
                // Salvar no banco
                rankedFiles.forEach(file => db.saveFile(file));
                db.saveSearch(query, 'files', rankedFiles.length);
                
                displayFileResults(rankedFiles, query);
                updateStats();
                
            } catch (error) {
                showNotification('Erro na busca de arquivos: ' + error.message, 'error');
            }
        }

        function getRelatedExtensions(fileType) {
            const extensions = {
                'Imagem': ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp', 'tiff'],
                'Vídeo': ['mp4', 'avi', 'mkv', 'mov', 'wmv', 'flv', 'webm', 'm4v'],
                'Áudio': ['mp3', 'wav', 'flac', 'aac', 'ogg', 'm4a', 'wma'],
                'Documento': ['pdf', 'doc', 'docx', 'txt', 'rtf', 'odt'],
                'Planilha': ['xls', 'xlsx', 'csv', 'ods'],
                'Apresentação': ['ppt', 'pptx', 'odp'],
                'Código': ['js', 'html', 'css', 'py', 'java', 'cpp', 'php'],
                'Compactado': ['zip', 'rar', '7z', 'tar', 'gz']
            };
            
            return extensions[fileType] || [];
        }

        function rankSearchResults(results, query) {
            return results.map(item => {
                let score = 0;
                const queryLower = query.toLowerCase();
                const nameLower = item.name.toLowerCase();
                const descLower = (item.description || '').toLowerCase();
                
                // Pontuação por correspondência exata no nome
                if (nameLower.includes(queryLower)) score += 10;
                
                // Pontuação por correspondência na descrição
                if (descLower.includes(queryLower)) score += 5;
                
                // Pontuação por número de membros/popularidade
                if (item.members) score += Math.log10(item.members);
                
                // Pontuação por atividade recente
                if (item.lastActivity) {
                    const daysSince = (Date.now() - new Date(item.lastActivity)) / (1000 * 60 * 60 * 24);
                    score += Math.max(0, 5 - daysSince / 30);
                }
                
                // Penalizar por inatividade
                if (item.inactive) score -= 5;
                
                return { ...item, relevanceScore: score };
            }).sort((a, b) => b.relevanceScore - a.relevanceScore);
        }

        async function simulateAdvancedSearch(query, method, platform) {
            // Simular delay de rede
            await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 1000));
            
            const results = [];
            const numResults = Math.floor(Math.random() * 15) + 5;
            
            for (let i = 0; i < numResults; i++) {
                const group = {
                    id: `${platform}_${Date.now()}_${i}`,
                    name: `${query} ${getRandomGroupSuffix()}`,
                    platform: platform.charAt(0).toUpperCase() + platform.slice(1),
                    members: Math.floor(Math.random() * 50000) + 100,
                    description: `Grupo sobre ${query} encontrado via ${method}`,
                    category: getCategoryFromQuery(query),
                    language: detectLanguage(query),
                    lastActivity: new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000),
                    verified: Math.random() > 0.7,
                    private: Math.random() > 0.6,
                    link: `https://t.me/${query.replace(/\s+/g, '')}_${i}`
                };
                
                results.push(group);
            }
            
            return results;
        }

        function getRandomGroupSuffix() {
            const suffixes = ['Brasil', 'Community', 'Official', 'Chat', 'Group', 'Channel', 'Hub', 'Network'];
            return suffixes[Math.floor(Math.random() * suffixes.length)];
        }

        function getCategoryFromQuery(query) {
            const categories = {
                'música': 'Entretenimento',
                'filme': 'Entretenimento',
                'tecnologia': 'Tecnologia',
                'negócio': 'Negócios',
                'educação': 'Educação',
                'saúde': 'Saúde',
                'esporte': 'Esportes'
            };
            
            for (const [key, category] of Object.entries(categories)) {
                if (query.toLowerCase().includes(key)) return category;
            }
            
            return 'Geral';
        }

        function detectLanguage(query) {
            const portugueseWords = ['de', 'da', 'do', 'em', 'para', 'com', 'por', 'são', 'não'];
            const hasPortuguese = portugueseWords.some(word => query.toLowerCase().includes(word));
            return hasPortuguese ? 'Português' : 'Inglês';
        }

        function removeDuplicatesAndFilter(groups, filters) {
            const seen = new Set();
            const unique = [];
            
            for (const group of groups) {
                const key = `${group.name.toLowerCase()}_${group.platform}`;
                if (!seen.has(key)) {
                    seen.add(key);
                    
                    // Aplicar filtros
                    if (filters.platform !== 'Todas' && group.platform !== filters.platform) continue;
                    if (filters.language !== 'Todos' && group.language !== filters.language) continue;
                    if (group.members < filters.minMembers) continue;
                    
                    unique.push(group);
                }
            }
            
            return unique;
        }

        async function deepFileSearchGitHub(queries, extensions) {
            const results = [];
            for (const query of queries) {
                for (const ext of extensions) {
                    const files = await simulateFileSearch(query, ext, 'GitHub');
                    results.push(...files);
                }
            }
            return results;
        }

        async function deepFileSearchArchive(queries, extensions) {
            const results = [];
            for (const query of queries) {
                const files = await simulateFileSearch(query, 'archive', 'Internet Archive');
                results.push(...files);
            }
            return results;
        }

        async function deepFileSearchTorrent(queries, extensions) {
            const results = [];
            for (const query of queries) {
                const files = await simulateFileSearch(query, 'torrent', 'Torrent');
                results.push(...files);
            }
            return results;
        }

        async function deepFileSearchCloud(queries, extensions) {
            const results = [];
            for (const query of queries) {
                const files = await simulateFileSearch(query, 'cloud', 'Cloud Storage');
                results.push(...files);
            }
            return results;
        }

        async function deepFileSearchFTP(queries, extensions) {
            const results = [];
            for (const query of queries) {
                const files = await simulateFileSearch(query, 'ftp', 'FTP Server');
                results.push(...files);
            }
            return results;
        }

        async function deepFileSearchP2P(queries, extensions) {
            const results = [];
            for (const query of queries) {
                const files = await simulateFileSearch(query, 'p2p', 'P2P Network');
                results.push(...files);
            }
            return results;
        }

        async function simulateFileSearch(query, type, source) {
            await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 700));
            
            const results = [];
            const numResults = Math.floor(Math.random() * 10) + 3;
            
            for (let i = 0; i < numResults; i++) {
                const file = {
                    id: `file_${Date.now()}_${i}`,
                    name: `${query}_${type}_${i + 1}`,
                    type: getFileTypeFromExtension(type),
                    size: (Math.random() * 100 + 1).toFixed(1) + ' MB',
                    source: source,
                    quality: Math.random() > 0.5 ? 'HD' : 'SD',
                    seeders: Math.floor(Math.random() * 1000),
                    downloadUrl: `https://example.com/download/${query}_${i}`
                };
                results.push(file);
            }
            
            return results;
        }

        function getFileTypeFromExtension(ext) {
            const types = {
                'mp4': 'Vídeo', 'avi': 'Vídeo', 'mkv': 'Vídeo',
                'mp3': 'Áudio', 'flac': 'Áudio', 'wav': 'Áudio',
                'jpg': 'Imagem', 'png': 'Imagem', 'gif': 'Imagem',
                'pdf': 'Documento', 'doc': 'Documento', 'txt': 'Documento',
                'zip': 'Compactado', 'rar': 'Compactado'
            };
            return types[ext] || 'Arquivo';
        }

        function rankFileResults(files, query) {
            return files.map(file => {
                let score = 0;
                const queryLower = query.toLowerCase();
                const nameLower = file.name.toLowerCase();
                
                if (nameLower.includes(queryLower)) score += 10;
                if (file.quality === 'HD') score += 3;
                if (file.seeders > 100) score += 2;
                
                return { ...file, relevanceScore: score };
            }).sort((a, b) => b.relevanceScore - a.relevanceScore);
        }

        function displayGroupResults(groups, query) {
            if (groups.length === 0) {
                document.getElementById('results').innerHTML = '<div class="no-results">Nenhum grupo encontrado</div>';
                return;
            }

            const html = groups.map(group => `
                <div class="result-item">
                    <div class="result-header">
                        <h3>${group.name}</h3>
                        <span class="platform-badge ${group.platform.toLowerCase()}">${group.platform}</span>
                    </div>
                    <p class="result-description">${group.description}</p>
                    <div class="result-stats">
                        <span>?? ${group.members.toLocaleString()} membros</span>
                        <span>?? ${group.language}</span>
                        <span>?? ${group.category}</span>
                    </div>
                    <div class="result-actions">
                        <button onclick="window.open('${group.link}')" class="btn-access">?? Acessar</button>
                        <button onclick="extractMedia('${group.id}')" class="btn-extract">?? Extrair Mídia</button>
                        <button onclick="toggleFavorite('${group.id}', ${JSON.stringify(group).replace(/"/g, '&quot;')})" class="btn-favorite">? Favoritar</button>
                    </div>
                </div>
            `).join('');

            document.getElementById('results').innerHTML = html;
        }

        function displayFileResults(files, query) {
            if (files.length === 0) {
                document.getElementById('results').innerHTML = '<div class="no-results">Nenhum arquivo encontrado</div>';
                return;
            }

            const html = files.map(file => `
                <div class="result-item">
                    <div class="result-header">
                        <h3>${file.name}</h3>
                        <span class="file-type-badge">${file.type}</span>
                    </div>
                    <div class="result-stats">
                        <span>?? ${file.size}</span>
                        <span>?? ${file.source}</span>
                        <span>? ${file.seeders} seeders</span>
                    </div>
                    <div class="result-actions">
                        <button onclick="window.open('${file.downloadUrl}')" class="btn-download">?? Download</button>
                        <button onclick="toggleFavorite('${file.id}', ${JSON.stringify(file).replace(/"/g, '&quot;')})" class="btn-favorite">? Favoritar</button>
                    </div>
                </div>
            `).join('');

            document.getElementById('results').innerHTML = html;
        }

        async function deepSearchWhatsApp(queries, minMembers) {
            const results = [];
            for (const query of queries) {
                const groups = await simulateAdvancedSearch(query, 'whatsapp', 'WhatsApp');
                results.push(...groups.filter(g => g.members >= minMembers));
            }
            return results;
        }

        async function deepSearchDiscord(queries, minMembers) {
            const results = [];
            for (const query of queries) {
                const groups = await simulateAdvancedSearch(query, 'discord', 'Discord');
                results.push(...groups.filter(g => g.members >= minMembers));
            }
            return results;
        }

        async function deepSearchReddit(queries) {
            const results = [];
            for (const query of queries) {
                const groups = await simulateAdvancedSearch(query, 'reddit', 'Reddit');
                results.push(...groups);
            }
            return results;
        }

        async function deepSearchGitHub(queries) {
            const results = [];
            for (const query of queries) {
                const groups = await simulateAdvancedSearch(query, 'github', 'GitHub');
                results.push(...groups);
            }
            return results;
        }

        async function deepSearchSocialMedia(queries) {
            const results = [];
            for (const query of queries) {
                const groups = await simulateAdvancedSearch(query, 'social', 'Social Media');
                results.push(...groups);
            }
            return results;
        }

        // Existing HTML structure
        <div class="header">
            <!-- Substituindo ?? por ?? (emoji ninja) -->
            <h1>?? Ninja Search Tool - Ferramenta de Pesquisa Avançada</h1>
        </div>
